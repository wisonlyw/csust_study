#include <bits/stdc++.h>
using namespace std;

static vector<int> primes;

// Sieve up to 1e6
void sieve(int N = 1000000) {
    vector<bool> is_prime(N + 1, true);
    is_prime[0] = is_prime[1] = false;
    for (int i = 2; i * 1LL * i <= N; ++i) {
        if (is_prime[i]) {
            for (int j = i * i; j <= N; j += i) is_prime[j] = false;
        }
    }
    for (int i = 2; i <= N; ++i) if (is_prime[i]) primes.push_back(i);
}

// Factor k into primes <= 1e6; returns (p, e)
vector<pair<long long,int>> factorize(long long k) {
    vector<pair<long long,int>> fac;
    long long tmp = k;
    for (int p : primes) {
        if (1LL * p * p > tmp) break;
        if (tmp % p == 0) {
            int e = 0;
            while (tmp % p == 0) {
                tmp /= p;
                ++e;
            }
            fac.emplace_back((long long)p, e);
        }
    }
    if (tmp > 1) {
        // tmp is prime (guaranteed <= 1e6 by problem statement)
        fac.emplace_back(tmp, 1);
    }
    return fac;
}

// Build mask counts for an array against kâ€™s factorization
template <typename It>
void build_counts(It begin, It end, long long k,
                  const vector<pair<long long,int>>& fac,
                  vector<long long>& cnt) {
    int m = (int)fac.size();
    long long fullMask = (m == 64) ? -1 : ((1LL << m) - 1); // but m will be small
    for (auto it = begin; it != end; ++it) {
        long long x = *it;
        if (x == 0) continue; // 0 canâ€™t divide positive k
        if (k % x != 0) continue; // must divide k
        long long mask = 0;
        long long y = x;
        for (int t = 0; t < m; ++t) {
            long long p = fac[t].first;
            int e_need = fac[t].second;
            int e_have = 0;
            while (y % p == 0) {
                y /= p;
                ++e_have;
                if (e_have > e_need) break; // early stop; though k%x==0 prevents this
            }
            if (e_have == e_need) mask |= (1LL << t);
        }
        // Since k % x == 0, y should be 1 (no extra primes). Safe to count.
        cnt[(size_t)mask] += 1;
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    sieve();

    int T;
    if (!(cin >> T)) return 0;
    while (T--) {
        int n;
        long long k;
        cin >> n >> k;
        vector<long long> a(n), b(n);
        for (int i = 0; i < n; ++i) cin >> a[i];
        for (int i = 0; i < n; ++i) cin >> b[i];

        // Factor k
        auto fac = factorize(k);
        int m = (int)fac.size();

        // Handle k == 1 quickly: only ai == 1 and bj == 1 work
        if (m == 0) {
            long long cntA1 = 0, cntB1 = 0;
            for (auto x : a) if (x == 1) ++cntA1;
            for (auto y : b) if (y == 1) ++cntB1;
            cout << (cntA1 * cntB1) << "\n";
            continue;
        }

        size_t SZ = 1ULL << m;
        vector<long long> cntA(SZ, 0), cntB(SZ, 0);

        build_counts(a.begin(), a.end(), k, fac, cntA);
        build_counts(b.begin(), b.end(), k, fac, cntB);

        // Superset zeta transform on cntB to get superset sums
        vector<long long> supB = cntB;
        for (int i = 0; i < m; ++i) {
            for (size_t mask = 0; mask < SZ; ++mask) {
                if (((mask >> i) & 1) == 0) {
                    supB[mask] += supB[mask | (1ULL << i)];
                }
            }
        }

        long long fullMask = (long long)SZ - 1;
        long long ans = 0;
        for (size_t mask = 0; mask < SZ; ++mask) {
            long long need = fullMask ^ (long long)mask; // bits missing in A must be covered by B
            ans += cntA[mask] * supB[(size_t)need];
        }

        cout << ans << "\n";
    }

    return 0;
}
ä¾‹å­
è®¾ 
ð‘˜
=
12
=
2
2
â‹…
3
1
ã€‚ æ‰€ä»¥è´¨å› å­é›†åˆæ˜¯ 
{
2
,
3
}
ï¼ŒæŒ‡æ•°åˆ†åˆ«æ˜¯ 
ð‘’
1
=
2
,
ð‘’
2
=
1
ã€‚ é‚£ä¹ˆ fullMask = 11ï¼ˆäºŒè¿›åˆ¶ï¼‰ã€‚

æ­¥éª¤ 1ï¼šçœ‹æ•°ç»„å…ƒç´ 
å‡è®¾

ð‘Ž
=
[
2
,
4
,
6
]

ð‘
=
[
3
,
12
]

æ­¥éª¤ 2ï¼šè®¡ç®—æŽ©ç 
å¯¹æ¯ä¸ªæ•°ï¼Œå…ˆçœ‹å®ƒæ˜¯å¦æ•´é™¤ 
ð‘˜
=
12
ï¼Œå†çœ‹å®ƒåœ¨æ¯ä¸ªè´¨å› å­ä¸Šçš„æŒ‡æ•°æ˜¯å¦â€œè¾¾æ ‡â€ã€‚

å¯¹ 
ð‘Ž
ï¼š

2
=
2
1
ï¼Œåœ¨ 2 ä¸ŠæŒ‡æ•° 1 < 2ï¼Œä¸è¾¾æ ‡ï¼›åœ¨ 3 ä¸ŠæŒ‡æ•° 0 < 1ï¼Œä¸è¾¾æ ‡ â†’ æŽ©ç  = 00

4
=
2
2
ï¼Œåœ¨ 2 ä¸ŠæŒ‡æ•° 2 = 2ï¼Œè¾¾æ ‡ï¼›åœ¨ 3 ä¸ŠæŒ‡æ•° 0 < 1ï¼Œä¸è¾¾æ ‡ â†’ æŽ©ç  = 10

6
=
2
1
â‹…
3
1
ï¼Œåœ¨ 2 ä¸ŠæŒ‡æ•° 1 < 2ï¼Œä¸è¾¾æ ‡ï¼›åœ¨ 3 ä¸ŠæŒ‡æ•° 1 = 1ï¼Œè¾¾æ ‡ â†’ æŽ©ç  = 01

å¯¹ 
ð‘
ï¼š

3
=
3
1
ï¼Œåœ¨ 2 ä¸ŠæŒ‡æ•° 0 < 2ï¼Œä¸è¾¾æ ‡ï¼›åœ¨ 3 ä¸ŠæŒ‡æ•° 1 = 1ï¼Œè¾¾æ ‡ â†’ æŽ©ç  = 01

12
=
2
2
â‹…
3
1
ï¼Œåœ¨ 2 ä¸ŠæŒ‡æ•° 2 = 2ï¼Œè¾¾æ ‡ï¼›åœ¨ 3 ä¸ŠæŒ‡æ•° 1 = 1ï¼Œè¾¾æ ‡ â†’ æŽ©ç  = 11

æ­¥éª¤ 3ï¼šé…å¯¹
æˆ‘ä»¬è¦æ‰¾ 
mask
(
ð‘Ž
)
â€…â€Š
âˆ£
â€…â€Š
mask
(
ð‘
)
=
11
ã€‚

ð‘Ž
=
2
 (00) + 
ð‘
=
3
 (01) â†’ 01 â‰  11 âŒ

ð‘Ž
=
2
 (00) + 
ð‘
=
12
 (11) â†’ 11 âœ…

ð‘Ž
=
4
 (10) + 
ð‘
=
3
 (01) â†’ 11 âœ…

ð‘Ž
=
4
 (10) + 
ð‘
=
12
 (11) â†’ 11 âœ…

ð‘Ž
=
6
 (01) + 
ð‘
=
3
 (01) â†’ 01 â‰  11 âŒ

ð‘Ž
=
6
 (01) + 
ð‘
=
12
 (11) â†’ 11 âœ…

æ‰€ä»¥ä¸€å…±æœ‰ 4 å¯¹åˆæ³•çš„ 
(
ð‘–
,
ð‘—
)
ã€‚

æ•°å­¦åŽŸç†æ€»ç»“
LCM = k â‡” æ¯ä¸ªè´¨å› å­éƒ½å¿…é¡»â€œè¢«è¦†ç›–â€ã€‚

ç”¨æŽ©ç è¡¨ç¤ºè¦†ç›–æƒ…å†µï¼Œé—®é¢˜å°±å˜æˆäº†ï¼š æœ‰å¤šå°‘å¯¹æŽ©ç çš„å¹¶é›†ç­‰äºŽå…¨ 1ã€‚
