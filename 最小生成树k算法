#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

struct Edge {
    int u, v, weight;
    // 重载小于运算符，便于排序
    bool operator<(const Edge& other) const {
        return weight < other.weight;
    }
};

class UnionFind {
    vector<int> parent;
public:
    UnionFind(int n) : parent(n) { for(int i=0; i<n; ++i) parent[i] = i; }
    int find(int x) {
        return parent[x] == x ? x : parent[x] = find(parent[x]); // 路径压缩
    }
    void unite(int x, int y) {
        parent[find(x)] = find(y);
    }
};

vector<Edge> kruskalMST(vector<Edge>& edges, int V) {
    sort(edges.begin(), edges.end()); // 1. 边按权值排序
    UnionFind uf(V);
    vector<Edge> mst;
    int edgeCount = 0;

    for (Edge& e : edges) {
        if (uf.find(e.u) != uf.find(e.v)) { // 2. 判断是否成环
            uf.unite(e.u, e.v);
            mst.push_back(e);
            if (++edgeCount == V-1) break; // 树已有V-1条边，完成
        }
    }
    return mst;
}
