/*
// ----- 3. 计算每行/每列/每个 3x3 宫的初始奇偶（0 表示偶，1 表示奇） -----
int rowP[9]={0}, colP[9]={0}, blockP[9]={0};
for(int i=0;i<9;i++) for(int j=0;j<9;j++){
rowP[i]^=a[i][j]; // 行异或累积
colP[j]^=a[i][j]; // 列异或累积
blockP[(i/3)*3 + (j/3)] ^= a[i][j]; // 3x3 宫的索引为 (i/3)*3 + (j/3)
}


// ----- 4. 预处理：对所有 0..511 的 9-bit 掩码，计算 popcount 与其对组内宫的影响 block3 -----
vector<int> masks_by_parity[2]; // 按掩码 popcount 的奇偶分组：0->偶数个1，1->奇数个1
int popc[1<<9], block3[1<<9]; // popc[m]：掩码 m 的 1 的个数；block3[m]：m 对当前行组内三个宫的影响（3-bit）
for(int m=0;m<512;m++){
popc[m]=__builtin_popcount((unsigned)m);
int b=0;
// 对掩码的每一位 c（0..8）检查是否为1，若为1则该位影响其所在的子宫（c/3 -> 0..2）
for(int c=0;c<9;c++) if(m&(1<<c)) b |= 1<<(c/3);
block3[m]=b;
masks_by_parity[popc[m]&1].push_back(m);
}


// ----- 5. 目标与初始状态：列的初始奇偶打包成一个 9-bit 的 startColMask；每个行组的 3-bit 目标 blockGroupTarget -----
int startColMask=0;
for(int c=0;c<9;c++) if(colP[c]) startColMask |= 1<<c;


int blockGroupTarget[3]={0};
for(int g=0;g<3;g++){
int v=0;
for(int j=0;j<3;j++) if(blockP[g*3 + j]) v |= 1<<j; // 每组三个 3x3 宫的奇偶目标
blockGroupTarget[g]=v;
}


// ----- 6. DP 初始化 -----
// 状态索引：idx = col_mask * 8 + groupBits，其中 col_mask in [0..511], groupBits in [0..7]
const int STATES = 512*8;
vector<int> dp(STATES, INF), ndp(STATES, INF);
// 初始状态：列奇偶为 startColMask，groupBits = 0，代价 0
dp[startColMask*8 + 0] = 0;


// ----- 7. 按行进行 DP 转移 -----
for(int r=0;r<9;r++){
fill(ndp.begin(), ndp.end(), INF);
int needParity = rowP[r]; // 当前行要求掩码 m 的 popcount 的奇偶要等于 needParity
int grp = r/3; // 当前行处于第 grp 组（0..2）
bool last = (r%3==2); // 是否为该组的最后一行（需要强制检查组目标）


// 遍历所有可能的 (col_mask, groupBits) 状态
for(int col_mask=0; col_mask<512; ++col_mask){
for(int gb=0; gb<8; ++gb){
int idx = col_mask*8 + gb;
if(dp[idx]==INF) continue; // 不可达状态跳过
int base = dp[idx];
// 枚举所有满足行奇偶性的掩码 m（即 popcount(m) 的奇偶 = needParity）
for(int m : masks_by_parity[needParity]){
int nc = col_mask ^ m; // 新的列奇偶
int ng = gb ^ block3[m]; // 新的组内宫奇偶
int cost = base + popc[m]; // 新的代价


if(last){
// 若是本组的最后一行，必须使组内宫的奇偶等于目标
if(ng != blockGroupTarget[grp]) continue;
ng = 0; // 进入下一组时清零（下一组开始时没有累积）
}
int nidx = nc*8 + ng;
if(cost < ndp[nidx]) ndp[nidx] = cost; // 取最小代价
}
}
}
dp.swap(ndp); // 下一行继续
}


// ----- 8. 结果读取：处理完 9 行后，目标是 col_mask == 0 且 groupBits == 0 -----
int ans = dp[0*8 + 0];
if(ans>=INF) cout << -1 << "\n"; // 理论上可能不存在解，输出 -1
else cout << ans << "\n"; // 最少翻转次数
return 0;
}

#include <bits/stdc++.h>
using namespace std;

int ans = 1000000;
int current_val = 0;

// 检查是否所有行/列/3x3块均为偶数个1
bool seek(const vector<vector<int>>& grid, const vector<int>& cols, const vector<int>& rows) {
    for (int i = 0; i < 3; i++)
        for (int j = 0; j < 3; j++)
            if (grid[i][j] % 2 == 1) return false;
    for (int i = 0; i < 9; i++)
        if (cols[i] % 2 == 1 || rows[i] % 2 == 1) return false;
    return true;
}

// 启发式下界：需要至少的操作数（可证明为下界）
int heuristic(const vector<vector<int>>& grid, const vector<int>& cols, const vector<int>& rows) {
    int row_odd = 0, col_odd = 0, grid_odd = 0;
    for (int i = 0; i < 9; i++) {
        if (cols[i] % 2 == 1) row_odd++;
        if (rows[i] % 2 == 1) col_odd++;
    }
    for (int i = 0; i < 3; i++)
        for (int j = 0; j < 3; j++)
            if (grid[i][j] % 2 == 1) grid_odd++;
    return max(max(row_odd, col_odd), grid_odd);
}

// IDA* 搜索：加入 start 参数，保证组合无重复（下次只能选 pos+1 及以后）
bool solve(vector<string>& Sudoku, vector<vector<int>>& grid, vector<int>& cols, vector<int>& rows, int max_depth, int start) {
    if (current_val > max_depth) return false;
    if (seek(grid, cols, rows)) {
        ans = min(ans, current_val);
        return true;
    }
    int h = heuristic(grid, cols, rows);
    if (current_val + h > max_depth) return false;

    // 关键改动：从 start 到 80 枚举，保证每次选的位置严格单调递增（组合）
    for (int pos = start; pos < 81; pos++) {
        int i = pos / 9, j = pos % 9;
        // 翻转 (i,j)
        char original_val = Sudoku[i][j];
        int change = (original_val == '0') ? 1 : -1;
        Sudoku[i][j] = (original_val == '0') ? '1' : '0';
        current_val++;
        grid[i/3][j/3] += change;
        cols[i] += change;  // 注意：这里 cols 存放的是每一行的 1 数（命名可交换）
        rows[j] += change;  // rows 存放每一列的 1 数

        // 递归，下一次只能选 pos+1 及之后的位置（避免排列重复）
        if (solve(Sudoku, grid, cols, rows, max_depth, pos + 1)) {
            // 可返回 true 提前退出以加快找到任意一个满足深度的方案
            Sudoku[i][j] = original_val;
            current_val--;
            grid[i/3][j/3] -= change;
            cols[i] -= change;
            rows[j] -= change;
            return true;
        }

        // 回溯恢复
        Sudoku[i][j] = original_val;
        current_val--;
        grid[i/3][j/3] -= change;
        cols[i] -= change;
        rows[j] -= change;
    }
    return false;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    vector<string> Sudoku(9);
    for (int i = 0; i < 9; i++) cin >> Sudoku[i];

    vector<vector<int>> grid(3, vector<int>(3, 0));
    vector<int> cols(9, 0);
    vector<int> rows(9, 0);
    for (int i = 0; i < 9; i++) {
        for (int j = 0; j < 9; j++) {
            if (Sudoku[i][j] == '1') {
                grid[i/3][j/3]++;
                cols[i]++;   // 注意：这里 cols 表示第 i 行的 1 的个数
                rows[j]++;   // rows 表示第 j 列的 1 的个数
            }
        }
    }

    if (seek(grid, cols, rows)) {
        cout << 0 << "\n";
        return 0;
    }

    // 迭代加深搜索 max_depth，从 1 开始
    for (int max_depth = 1; max_depth <= 81; max_depth++) {
        current_val = 0;
        if (solve(Sudoku, grid, cols, rows, max_depth, 0)) {
            cout << ans << "\n";
            return 0;
        }
    }
    // 理论上总会有解，但保险返回
    cout << -1 << "\n";
    return 0;
}
